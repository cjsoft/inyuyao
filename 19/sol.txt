rng

这题的内在逻辑是要找一个集合使得这个集合是答案的概率最大。记这个集合是S，串是w，也就是要找到一个集合使得P(S|w)最大。

根据条件概率这一套理论(https://en.wikipedia.org/wiki/Bayes%27_theorem)，我们只要找到S使得P(w|S)*P(S)最大，P(S)是一样的，而P(w|S)可以按照题意模拟计算。

当字母比较少的时候可以枚举S这个集合。

当字母比较多的时候枚举集合会T，这个时候只要多搞几个起始点爬山或者模拟退火就好了。

tourist

由于期望的线性性，x和y可以分开来算。

考虑怎么计算x。由于线性性，可以每个x轴的微元，求一下随机两个点通过这个坐标的概率，然后积分即可。

比如P(t)表示随机两个点的线段通过x=t这条直线的概率，那么答案就是对P(t)dt积分。

对于x=t这条直线，如果线段通过，那么一定是一个点在左边，一个点在右边，或者反过来。

那么它的概率为2*左边部分面积*右边部分面积/总面积^2。

接着考虑怎么求积分。按顶点的x坐标切，每一段中，长度是一次函数(与x=t交的长度)，所以面积是二次函数，左边面积*右边面积是四次函数。对于这个四次函数，你可以尝试直接算系数或者使用高斯积分公式(https://en.wikipedia.org/wiki/Gaussian_quadrature)。(高斯积分有着更好的精度)

接着考虑怎么算出这个一次函数，对于多边形的一条边，如果从右到左为上边界，从左到右为下边界，是上边界就加，下边界就减，然后从左到右扫过来的时候维护一下这个一次函数就行了。

star

首先如果有n个非负整数，它们的和为t的方案数为C(t+n-1,n-1)。

如果第i个数范围在[li,ri]之间，要计算和为t的方案，那么我们需要容斥每个数>=li和>=ri+1，假设每个数的下界为vi，那么方案数为C(t-sum(vi)+n-1,n-1)，这里我们记V=sum(vi)。

在这个问题中，我们要求t是好的，并且t>=V，由于t不会超过d^510，所以可以当成从V到d^510-1求和。

然后注意到C(a+b,n)=sum(C(a,i)*C(b,n-i),i=0..n)，于是我们只要求出C(t,0),...,C(t,n-1)的和，然后通过这个式子可以将这些数整体加一个值，从而求出C(t-V+n-1,n-1)。

然后转化成要求0..V-1之间t的C(t,0),...,C(t,n-1)，这个使用数位dp+前缀和优化即可。

在dp转移的过程中相当于整体加一个值，用上面的那个恒等式搞一下就好了。

时间复杂度O(2^n*n^2*l)，其中l为数字的长度。
